import numpy as np
from typing import List, Callable
from City import City
from Direction import Direction
from Grid import Grid


class GeneticSolver:
    """
    GeneticSolver is a class that implements a genetic algorithm to optimize traffic light configurations in a city grid.
    The goal is to minimize the average waiting time for cars across multiple city scenarios.
    """

    def __init__(self, population_size: int, mutation_rate: float, generations: int, n: int, m: int, t: int):
        """
        Initializes the GeneticSolver with the necessary parameters.

        Parameters:
        - population_size (int): The number of solutions in each generation's population.
        - mutation_rate (float): The probability of a mutation occurring at each gene in a solution.
        - generations (int): The number of generations to evolve the population.
        - n (int): The number of rows in the city grid.
        - m (int): The number of columns in the city grid.
        - t (int): The number of time steps (ticks) to consider in each solution.
        """
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.generations = generations
        self.n = n
        self.m = m
        self.t = t

    def generate_random_solution(self) -> np.ndarray:
        """
        Generates a random solution, which is a 3D array representing the traffic light directions
        (Horizontal or Vertical) for each junction at each time step.

        Returns:
        - np.ndarray: A (t, n, m) array where each element is either Direction.HORIZONTAL or Direction.VERTICAL.
        """
        # TODO: check coordinates
        return np.random.choice([Direction.HORIZONTAL, Direction.VERTICAL], size=(self.t, self.n, self.m))

    def crossover(self, parent1: np.ndarray, parent2: np.ndarray) -> np.ndarray:
        """
        Performs single-point crossover between two parent solutions to produce a child solution.

        Parameters:
        - parent1 (np.ndarray): The first parent solution.
        - parent2 (np.ndarray): The second parent solution.

        Returns:
        - np.ndarray: A new child solution generated by combining parts of parent1 and parent2.
        """
        crossover_point = np.random.randint(1, self.t)
        child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
        return child

    def mutate(self, solution: np.ndarray) -> np.ndarray:
        """
        Mutates a given solution by flipping the direction of traffic lights at random locations based on the
        mutation rate.

        Parameters:
        - solution (np.ndarray): The solution to be mutated.

        Returns:
        - np.ndarray: The mutated solution.
        """
        mutation_mask = np.random.random(solution.shape) < self.mutation_rate

        # Directly flip the directions using boolean indexing
        solution[mutation_mask & (solution == Direction.HORIZONTAL)] = Direction.VERTICAL
        solution[mutation_mask & (solution == Direction.VERTICAL)] = Direction.HORIZONTAL

        return solution

    def create_children(self, parents: np.ndarray) -> np.ndarray:
        """
        Creates a new population of offspring by performing crossover and mutation on the parent solutions.

        Parameters:
        - parents (np.ndarray): The parent solutions selected for reproduction.

        Returns:
        - np.ndarray: A new population of offspring solutions.
        """
        children = np.empty((self.population_size, self.t, self.n, self.m), dtype=object)
        for i in range(0, self.population_size, 2):
            parent1, parent2 = np.random.choice(len(parents), 2, replace=False)
            child1 = self.crossover(parents[parent1], parents[parent2])
            child2 = self.crossover(parents[parent2], parents[parent1])
            children[i, :, :, :] = self.mutate(child1)
            children[i + 1, :, :, :] = self.mutate(child2)

        return children

    def evaluate_solution(self, solution: np.ndarray, cities: List[City]) -> float:
        """
        Evaluates a solution by simulating it across multiple city scenarios and calculating the average waiting
        time for cars.

        Parameters:
        - solution (np.ndarray): The solution to be evaluated.
        - cities (List[City]): A list of City objects representing different traffic scenarios.

        Returns:
        - float: The average waiting time for cars, or infinity if not all cars reach their destinations.
        """
        total_avg_wait_time = 0
        for city in cities:
            for t in range(self.t):
                city.update_city(solution[t])


            if city.did_all_cars_arrive():
                total_avg_wait_time += city.grid.get_total_avg_wait_time()
            else:
                return np.inf

        return total_avg_wait_time / len(cities)

    def select_parents(self, population: np.ndarray, fitness_scores: np.ndarray) -> np.ndarray:
        """
        Selects parent solutions for the next generation using a fitness-proportionate selection method.

        Parameters:
        - population (np.ndarray): The current population of solutions.
        - fitness_scores (np.ndarray): The fitness scores of the current population.

        Returns:
        - np.ndarray: The selected parent solutions.
        """
        inverse_fitness = 1 / fitness_scores
        probabilities = inverse_fitness / np.sum(inverse_fitness)
        parent_indices = np.random.choice(len(population), size=self.population_size, p=probabilities)
        return population[parent_indices]

    def solve(self, num_cities: int, num_cars: int) -> np.ndarray[Direction]:
        """
        Runs the genetic algorithm to find the optimal traffic light configuration that minimizes average car waiting times.
        For each generation, it creates new random cities to evaluate the solutions.

        Parameters:
        - city_generator (Callable[[], City]): A function that generates a random City object.
        - num_cities (int): The number of cities to generate and evaluate for each generation.

        Returns:
        - np.ndarray: The best solution found after all generations.
        """
        population = [self.generate_random_solution() for _ in range(self.population_size)]

        for generation in range(self.generations):
            # Generate new random cities for this generation
            cities = City.generate_cities(self.n, self.m, num_cars, num_cities)

            fitness_scores = np.array([self.evaluate_solution(solution, cities) for solution in population])
            best_index = np.argmin(fitness_scores)  # TODO: get a single minimum
            best_solution = population[best_index]
            best_fitness = fitness_scores[best_index]

            print(f"Generation {generation + 1}: Best fitness = {best_fitness}")

            parents = self.select_parents(population, fitness_scores)
            offspring = self.create_children(parents)

            # Elitism: Keep the best solution
            #TODO: check if size of population change and if its OK
            population = np.concatenate((offspring[:-1], best_solution.reshape(1, self.t, self.n, self.m)))

        final_fitness_scores = np.array([self.evaluate_solution(solution, cities) for solution in population])
        best_final_index = np.argmin(final_fitness_scores)
        best_final_solution = population[best_final_index]
        best_final_fitness = final_fitness_scores[best_final_index]

        print(f"Final Best Fitness: {best_final_fitness}")

        return best_final_solution
